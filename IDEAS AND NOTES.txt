Local database / server:
    - buy a ~1TB hard drive to store the library of music
        - HDD is probably fine bc there won't be many users accessing it at once
    - Set up a server on my desktop to access library
    - could have it always on... probably not ideal
        - or could try booting up the server remotely upon starting the app?
        - ChatGPT gave options: 
            1. Wake-on-LAN (WoL) ‚Äì Wake Your PC Over the Network
                If your desktop is asleep or hibernating (not fully powered off), you can send a "magic packet" to wake it.
                Requirements:
                    - Your BIOS must support and enable Wake-on-LAN.
                    - Your PC must be connected via Ethernet (more reliable than Wi-Fi).
                    - You'll need your PC's MAC address.
                    - Your router needs to allow "broadcast" packets (sometimes tricky if you're behind NAT or CGNAT).

                Example Tool:
                    From another device, use something like:
                    - wakeonlan 00:11:22:33:44:55
                    Or an app like:
                    - Depicus WoL (Windows)
                    - WakeMeOnLan by NirSoft
                    - Unified Remote (mobile app)

            2. Remote Access Software ‚Äì If PC is Already On
                - If your desktop is running (or wakes via WoL), then you can:
                - SSH in (for Linux/macOS)
                - Use Remote Desktop (RDP) for Windows Pro
                - Use Chrome Remote Desktop, AnyDesk, TeamViewer, etc.
                
            - Important: Security Tips
                - If you're exposing a way to wake or access your desktop over the internet:
                - Use strong passwords / SSH keys
                - Only open necessary ports
                - Consider using a VPN like Tailscale or ZeroTier for secure access
    
    - Could use Ngrok? Talal told use abt this
        - What is ngrok? (ChatGPT response)
            ngrok is a tool that lets you securely expose your local server to the internet using a public URL.

            Think of it like:
            "A temporary bridge between your laptop and the web."

            üõ†Ô∏è What It Does:
            You run a local server (like your music API on http://localhost:5000), and ngrok gives you a public URL like:
                - https://abc123.ngrok.io
                - This URL forwards traffic to your local server, so people (or devices) outside your network can access it ‚Äî even if you're behind a firewall or NAT.

            üîê Why It's Useful:
            ‚úÖ Test your local app on your phone
            ‚úÖ Share your local project with a teammate or client
            ‚úÖ Use webhooks (e.g., from Stripe, GitHub, OpenAI)
            ‚úÖ Host temporary APIs, bots, dashboards, etc.

            üß† How It Works (Simplified):
                1. You run a command like:
                    - ngrok http 5000
                2. ngrok opens a secure tunnel from a public URL to localhost:5000
                3. Requests from the internet ‚Üí go through ngrok ‚Üí hit your local server

            üí° Example Use Cases:
                - Testing webhooks (/api/webhook) without deploying
                - Sharing your music streaming app with a friend
                - Running a demo site for someone without deploying to Vercel or Netlify

            üÜì Free vs Paid
            Feature	            Free Plan	  Paid Plan
            Random URLs	        ‚úÖ Yes	    ‚úÖ Yes
            Custom Subdomains	‚ùå No	    ‚úÖ Yes
            Persistent URLs	    ‚ùå No	    ‚úÖ Yes
            Auth/Access Control	‚ùå No	    ‚úÖ Yes

        - Using ngrok with Your Local Music Server
            1. Install ngrok
                If you haven‚Äôt already:
                - npm install -g ngrok
                - Or download it from https://ngrok.com/download

            2. Run Your Local Server
                Start your music-server:
                    - node server.js
                Make sure it says something like:
                    - Music server running at http://localhost:5000
            3. Expose It with ngrok
                In a new terminal window, run:
                    - ngrok http 5000
                You‚Äôll get a public URL like:
                    - Forwarding    https://a1b2c3d4.ngrok.io -> http://localhost:5000
                Copy that https://...ngrok.io URL ‚Äî it‚Äôs now your public music server!

            4. Access It From Anywhere
                Go to https://a1b2c3d4.ngrok.io/api/tracks ‚Üí lists your music

                Songs will stream from URLs like:
                    - https://a1b2c3d4.ngrok.io/music/chill.mp3
                Plug that into your frontend app or even your phone‚Äôs browser/audio player.

            üéß Example Integration (Frontend)
                const track = {
                name: 'chill.mp3',
                url: 'https://a1b2c3d4.ngrok.io/music/chill.mp3'
                };

                <audio controls src={track.url}></audio>
            
            üîí Pro Tips
            - Free ngrok accounts rotate URLs every time you restart unless you sign in and use ngrok config.
            - If you want persistent URLs or custom subdomains, you‚Äôll need a paid ngrok plan.
            - Don‚Äôt share your ngrok URL publicly unless you're okay with others accessing your music.

================================================================================================================================

OpenAI API: 

- I don't think the AI can directly query the DB... 
- to do this, our own server must be the one making the API call, or we need to use the OpenAI model as a tool inside your app, 
  not as a self-contained API-only source of truth
- Think of It Like This:
    - We send a request from our Next.js frontend (or any app)
    - That request hits our server
    - Our server:
        - Optionally queries local data (like our music API)
        - Crafts a custom prompt with this data
        - Sends that to OpenAI via their API
    - OpenAI responds
    - Our server sends that combined response back to our frontend









AI Music Search Documentation
Overview
This app is an AI powered, royalty-free music search engine, with playback + download capabilities. A user can enter a search prompt into the search bar, and the AI + Music DB will respond back with songs corresponding to the prompt. Results are displayed to the user, where they can then playback all the songs, or download any songs. 
Services
-	OpenAI 4o-mini API
o	https://platform.openai.com/docs/overview 
o	Our AI API of choice. We send a prompt to OpenAI, and it responds with search tags to use for our Jamendo search (music DB).
o	Location in code: 
ÔÇß	app / api / openai
-	Jamendo API
o	https://developer.jamendo.com/v3.0/docs 
o	Our resource for royalty-free music. We send the API the search tags to search by, and it responds with a JSON of all corresponding songs. Each song in the JSON contains info like name, artist, streaming link, download link, thumbnail, etc.
-	OAuth 2.0
o	Authorization framework. We use OAuth to authenticate users are legitimate, so we don‚Äôt have bots creating API requests (costs money)
-	Firebase
o	https://console.firebase.google.com/u/0/project/ai-song-search/overview 
o	Authentication
ÔÇß	Helps manage authentication (with OAuth)
ÔÇß	Google, Facebook, GitHub
o	Firestore
ÔÇß	Database, NoSQL (non-relational)
ÔÇß	Used for session management, stores tokens
‚Ä¢	providerAccessToken (OAuth)
‚Ä¢	jamendo_access_token
‚Ä¢	jamendo_refresh_token
Frameworks/Platforms
Node.js
-	The runtime that powers Next.js server-side rendering & APIs.
-	Location in code:
o	app / api / ... / route.js
React
-	Used inside .jsx files and components to render UI.
o	Components
o	Context
o	Hooks 
Next.js
-	The framework providing routing, APIs, and React integration.
-	Utilizes Next.js App Router
o	Location in code: 
o	app / (pages) / ‚Ä¶ / page.jsx
o	app / (pages) / ‚Ä¶ / layout.jsx
Material UI (MUI)
-	React component library (buttons, sliders, icons, etc.)
Vercel
-	Cloud deployment platform
-	Environment variables + secrets are found here
-	https://vercel.com/nick-grahams-projects/ai-music-search 
ESLint
-	Tool that analyzes your source code to find problems before you run it.
o	Errors (real bugs, like undefined variables).
o	Style issues (missing semicolons, unused imports, inconsistent spacing). 
Tailwind CSS
-	Our CSS Utility framework (flex, padding, margin, etc.)
Structure Overview
Below is the folder structure of the app. It is separated into a client/server (front-end/back-end) design, where the client and the server are distinct from each other. It is an important security consideration that any outbound requests to any APIs/DB, are not done client-side.
Client:
-	app/(pages) folder
-	app/components folder
-	context folder
-	hooks folder
Server:
-	app/api folder
-	lib folder
-	styles folder
-	utils folder
Codebase Structure
ÔÉò	[folder]
o	[folder description]
o	[file]
ÔÇß	[file description]
app
-	(pages)
o	Actual pages + their layouts. Client-side
o	Currently only one real ‚Äúpage‚Äú ‚Äì the home page
o	layout.jsx	
ÔÇß	context provider
o	(home)
ÔÇß	layout.jsx
‚Ä¢	* Main home layout *
ÔÇß	page.jsx 
‚Ä¢	* Main home page *
ÔÇß	User
‚Ä¢	User profile. Not yet implemented
‚Ä¢	[id]
‚Ä¢	Favorites
o	Login
ÔÇß	Not in use currently.
ÔÇß	callback
‚Ä¢	Not in use currently. ‚Äúcallback‚Äù screens used for logging into a Jamendo account.
‚Ä¢	jamendo-callback.jsx
‚Ä¢	page.jsx
-	api
o	Where API calls are handled. Server-side.
o	auth
ÔÇß	login
‚Ä¢	route.js
ÔÇß	logout
‚Ä¢	route.js
o	jamendo
ÔÇß	jamendo-search.js
ÔÇß	access-token
‚Ä¢	route.js
ÔÇß	jamendo-handler
‚Ä¢	go-to-jamendo.js
‚Ä¢	jamendo-auth.js
o	openai
ÔÇß	route.js
‚Ä¢	Entry and exit location of the front-end to back-end communication (when you hit search)
‚Ä¢	This encapsulates the entire API calling search process 
o	(additional functions are called from within this one)
ÔÇß	openai-handler
‚Ä¢	openai.js
o	session
ÔÇß	route.js
ÔÇß	session-handler
‚Ä¢	session.js
-	components
o	search-bar.jsx
ÔÇß	where the initial call to the back end is made
ÔÇß	await fetch(‚Äú/api/openai‚Äù, { ‚Ä¶ });
o	[other misc. components].jsx
o	audio
ÔÇß	[audio components].jsx
o	login
ÔÇß	[login components].jsx
context
-	Handles react context within the app (react hooks, state-based stuff, global values/functions). Client-side.
-	audio-player-context.jsx
o	tracks, setTracks, currentTrack, setCurrentTrack, isPlaying, setIsPlaying, etc.
-	auth-context.jsx
o	user, setUser, googleSignIn, etc.
hooks
-	Custom hooks
-	use-current-user.jsx
lib
-	Firebase and Firestore logic are handled here, among other things.
-	ai-tools.js
o	functions + tools used to assist AI search
-	authorize-calls.js
o	User is authorized here before any initial API call is made (before initial OpenAI call)
-	firebase-admin.js
-	firebase.js
-	search-data
o	lists of data used to search with (tags, etc.)
styles
-	customize-progress-bar.css
-	globals.css
-	theme.js
utils
-	clean.js

High Level Typical Flow
-	User enters prompt and clicks search button
-	Validate user with their ID token
-	If okay, call OpenAI API with user‚Äôs prompt + search tools
-	AI will respond with search tags to use for Jamendo API call
-	Format search tags for Jamendo API call
-	Call Jamendo API using formatted tags
-	Jamendo responds with all corresponding songs
-	Send OpenAI search results from Jamendo for its final response (the message back to the user)
-	Get AI response back
-	Load songs received earlier into an array in audio-player-context.jsx
-	Display each song into a result-card component
-	Display AI final response to user

Future Considerations
-	Change to Apple Music / Spotify API for a much larger library of music
-	User Playlists
o	Auto generate playlists
o	Based on prompt or based on particular artist/song
-	User Profiles
-	Song Recommendations based on given:
o	Song
o	Artist
o	Genre
-	Check out other LLMs
-	Dark Mode
-	UI Refinement
